<!DOCTYPE html>
<html>

<head>
    <title>TWIN Racer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta http-equiv="X-Compatible" content="IE=edge" />
    <link href="common.css" rel="stylesheet" type="text/css" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        .coin-animation {
            position: absolute;
            width: 20px;
            height: 20px;
            background-image: url('sprites/coin.png');
            background-size: cover;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>

<body>

    <div id="racer">
        <div id="hud">
            <span id="speed" class="hud"><span id="speed_value" class="value">0</span> mph</span>
            <span id="current_lap_time" class="hud">Time: <span id="current_lap_time_value" class="value">0.0</span></span>
            <span id="last_lap_time" class="hud">Last Lap: <span id="last_lap_time_value" class="value">0.0</span></span>
            <span id="fast_lap_time" class="hud">Fastest Lap: <span id="fast_lap_time_value" class="value">0.0</span></span>
            <span id="coin_count" class="hud">Coins: <span id="coin_count_value" class="value">0</span></span>
        </div>
        <canvas id="canvas">
            Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
        </canvas>
        Loading...
    </div>

    <audio id="music" loop>
        <source src="music/racer.ogg" type="audio/ogg">
        <source src="music/racer.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="coinSound">
        <source src="music/coinsound.aac" type="audio/aac">
        Your browser does not support the audio element.
    </audio>
    <span id="mute"></span>

    <script src="common.js"></script>
    <script src="game.js"></script>
    <script src="tg.js"></script>
    <script src="api.js"></script>

    <script>
        var firstLapComplete = false;
        var fps = 60;
        var step = 1 / fps;
        var width = 1024;
        var height = 768;
        var centrifugal = 0.3;
        var offRoadDecel = 0.99;
        var skySpeed = 0.001;
        var hillSpeed = 0.002;
        var treeSpeed = 0.003;
        var skyOffset = 0;
        var hillOffset = 0;
        var treeOffset = 0;
        var segments = [];
        var cars = [];
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');

        // Supersampling factor for higher resolution rendering
        var SUPERSAMPLING_FACTOR = 2;

        // Adjust the canvas size for supersampling
        canvas.width = window.innerWidth * SUPERSAMPLING_FACTOR;
        canvas.height = window.innerHeight * SUPERSAMPLING_FACTOR;

        // Scale down the rendering context to actual display size
        ctx.scale(1 / SUPERSAMPLING_FACTOR, 1 / SUPERSAMPLING_FACTOR);

        // Enable anti-aliasing (optional, generally enabled by default)
        ctx.imageSmoothingEnabled = true;

        var background = null;
        var sprites = null;
        var resolution = null;
        var roadWidth = 2000;
        var segmentLength = 200;
        var rumbleLength = 3;
        var trackLength = null;
        var lanes = 3;
        var fieldOfView = 100;
        var cameraHeight = 1000;
        var cameraDepth = null;
        var drawDistance = 300;
        var playerX = 0;
        var playerZ = null;
        var fogDensity = 5;
        var position = 0;
        var speed = 0;
        var maxSpeed = segmentLength / step;
        var accel = maxSpeed / 5;
        var breaking = -maxSpeed;
        var decel = -maxSpeed / 5;
        var offRoadDecel = -maxSpeed / 2;
        var offRoadLimit = maxSpeed / 4;
        var totalCars = 200;
        var currentLapTime = 0;
        var lastLapTime = null;
        var lastLapCoins = 0;

        var shakeAmount = 0;  // Intensity of the shake
        var shakeDecay = 0.9; // How quickly the shake decreases

        var isRaining = false;
        var rainDrops = [];
        var rainTimer = 0;
        var rainDuration = 5000; // Rain duration in milliseconds
        var rainDropCount = 100; // Number of raindrops

        var keyLeft = false;
        var keyRight = false;
        var keyFaster = false;
        var keySlower = false;

        var playerStraightSprite;
        var billboard01Sprite, billboard02Sprite, billboard03Sprite, billboard04Sprite;
        var billboard05Sprite, billboard06Sprite, billboard07Sprite, billboard08Sprite, billboard09Sprite;
        var tree1Sprite, tree2Sprite, deadTree1Sprite, deadTree2Sprite, palmTreeSprite;
        var columnSprite, boulder1Sprite, boulder2Sprite, boulder3Sprite;
        var bush1Sprite, bush2Sprite, cactusSprite, stumpSprite;
        var semiSprite, truckSprite, car01Sprite, car02Sprite, car03Sprite, car04Sprite;
        var coinSprite;

        var hud = {
            speed: { value: null, dom: document.getElementById('speed_value') },
            current_lap_time: { value: null, dom: document.getElementById('current_lap_time_value') },
            last_lap_time: { value: null, dom: document.getElementById('last_lap_time_value') },
            fast_lap_time: { value: null, dom: document.getElementById('fast_lap_time_value') },
            coin_count: { value: 0, dom: document.getElementById('coin_count_value') }
        };

        var coins = [];
        var coinTimer = 0;
        var coinDropInterval = 3000;

        document.addEventListener("DOMContentLoaded", function() {
            var music = document.getElementById('music');
            music.volume = 0.2;

            function startMusic() {
                music.play().then(function() {
                    console.log("Background music is playing.");
                }).catch(function(error) {
                    console.error("Background music could not be played:", error);
                });
            }

            document.body.addEventListener('click', function() {
                startMusic();
            }, { once: true });

            document.body.addEventListener('keydown', function() {
                startMusic();
            }, { once: true });
        });

        // Start Rain Functions

        function startRain() {
            isRaining = true;
            rainTimer = Util.randomInt(5000, 15000); // Rain for 5 to 15 seconds
            rainDrops = [];

            for (var i = 0; i < rainDropCount; i++) {
                rainDrops.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    speed: Math.random() * 5 + 5
                });
            }
        }

        function stopRain() {
            isRaining = false;
            rainDrops = []; // Clear raindrops
            rainTimer = Util.randomInt(10000, 30000); // Wait 10 to 30 seconds before raining again
        }

        function updateRain(dt) {
            if (isRaining) {
                for (var i = 0; i < rainDrops.length; i++) {
                    rainDrops[i].y += rainDrops[i].speed * dt;
                    if (rainDrops[i].y > height) {
                        rainDrops[i].y = 0;
                        rainDrops[i].x = Math.random() * width;
                    }
                }
                rainTimer -= dt * 1000;
                if (rainTimer <= 0) {
                    stopRain();
                }
            } else {
                rainTimer -= dt * 1000;
                if (rainTimer <= 0) {
                    startRain();
                }
            }
        }

        function renderRain() {
            if (!isRaining) return;

            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; // Light blue with some transparency
            for (var i = 0; i < rainDrops.length; i++) {
                var drop = rainDrops[i];
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x + 1, drop.y + 10); // Raindrop's length
                ctx.stroke();
            }
        }

        // Update Function

        function update(dt) {
            var playerSegment = findSegment(position + playerZ);
            var playerW = playerStraightSprite.width * SPRITES.SCALE;
            var playerH = playerStraightSprite.height * SPRITES.SCALE;
            var speedPercent = speed / maxSpeed;
            var dx = dt * 2 * speedPercent;
            var startPosition = position;
            var bounce = 0;

            // Dynamic camera adjustments
            var dynamicCameraHeight = 1000 - (speedPercent * 500); // Lower camera at higher speeds
            var cameraTilt = (playerSegment.p2.world.y - playerSegment.p1.world.y) * 2; // Swoop effect over hills

            updateCars(dt, playerSegment, playerW);

            position = Util.increase(position, dt * speed, trackLength);

            if (keyLeft) playerX -= dx;
            else if (keyRight) playerX += dx;

            playerX -= dx * speedPercent * playerSegment.curve * centrifugal;

            if (keyFaster) speed = Util.accelerate(speed, accel, dt);
            else if (keySlower) speed = Util.accelerate(speed, breaking, dt);
            else speed = Util.accelerate(speed, decel, dt);

            // Check if the player is off-road
            if ((playerX < -1) || (playerX > 1)) {
                if (speed > offRoadLimit) speed = Util.accelerate(speed, offRoadDecel, dt);

                // Add a bounce effect when the car is off-road
                bounce = Math.sin(Date.now() / 100) * 10;

                // Trigger screen shake when off-road
                shakeAmount = Math.min(10, shakeAmount + 5);
            }

            // Collision detection with other cars
            for (var n = 0; n < playerSegment.cars.length; n++) {
                var car = playerSegment.cars[n];
                var carW = car.sprite.width * SPRITES.SCALE;
                var carH = car.sprite.height * SPRITES.SCALE;

                var playerBoundingBox = {
                    left: playerX - playerW / 2,
                    right: playerX + playerW / 2,
                    top: playerZ,
                    bottom: playerZ + playerH
                };

                var carBoundingBox = {
                    left: car.offset - carW / 2,
                    right: car.offset + carW / 2,
                    top: car.z,
                    bottom: car.z + carH
                };

                // Check for bounding box overlap (collision)
                if (speed > car.speed) {
                    if (playerBoundingBox.right > carBoundingBox.left &&
                        playerBoundingBox.left < carBoundingBox.right &&
                        playerBoundingBox.bottom > carBoundingBox.top &&
                        playerBoundingBox.top < carBoundingBox.bottom) {

                        // Handle collision response
                        speed = car.speed * (car.speed / speed);
                        position = Util.increase(car.z, -playerZ, trackLength);

                        // Trigger a stronger shake on collision, but smoother
                        shakeAmount = Math.min(15, shakeAmount + 7);
                        break;
                    }
                }
            }

            playerX = Util.limit(playerX, -3, 3);
            speed = Util.limit(speed, 0, maxSpeed);

            skyOffset = Util.increase(skyOffset, skySpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
            hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
            treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);

            // Reduce shakeAmount over time for a smoother effect
            shakeAmount *= shakeDecay;
            if (shakeAmount < 0.5) shakeAmount = 0;

            if (position > playerZ) {
                if (currentLapTime && (startPosition < playerZ)) {
                    lastLapTime = currentLapTime;
                    lastLapCoins = hud.coin_count.value;
                    recordRaceRound(tgName, tgID, hud.coin_count.value, parseInt(lastLapTime));
                    hud.coin_count.value = 0;
                    currentLapTime = 0;
                    if (!firstLapComplete) {
                        firstLapComplete = true;
                    }
                    if (lastLapTime <= Util.toFloat(localStorage.fast_lap_time)) {
                        localStorage.fast_lap_time = lastLapTime;
                        updateHud('fast_lap_time', formatTime(lastLapTime));
                        document.getElementById('fast_lap_time').classList.add('fastest');
                        document.getElementById('last_lap_time').classList.add('fastest');
                    } else {
                        document.getElementById('fast_lap_time').classList.remove('fastest');
                        document.getElementById('last_lap_time').classList.remove('fastest');
                    }
                    updateHud('last_lap_time', formatTime(lastLapTime));
                    document.getElementById('last_lap_time').style.display = 'inline';
                } else {
                    currentLapTime += dt;
                }
            }

            updateHud('speed', 5 * Math.round(speed / 500));
            updateHud('current_lap_time', formatTime(currentLapTime));

            checkCoinCollection({ x: playerX, z: position + playerZ });

            coinTimer += dt * 1000;
            if (coinTimer >= coinDropInterval) {
                dropCoins();
                coinTimer = 0;
                coinDropInterval = Util.randomInt(2000, 5000);
            }

            // Apply the dynamic camera changes
            cameraHeight = dynamicCameraHeight + cameraTilt + bounce;

            // Update rain effect
            updateRain(dt);
        }

        // Render Function

        function render() {
            var baseSegment = findSegment(position);
            var basePercent = Util.percentRemaining(position, segmentLength);
            var playerSegment = findSegment(position + playerZ);
            var playerPercent = Util.percentRemaining(position + playerZ, segmentLength);
            var playerY = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
            var maxy = height;

            var x = 0;
            var dx = -(baseSegment.curve * basePercent);

            // Apply screen shake
            var shakeX = (Math.random() * 2 - 1) * shakeAmount;
            var shakeY = (Math.random() * 2 - 1) * shakeAmount;

            ctx.clearRect(0, 0, width, height);

            Render.background(ctx, backgroundSky, width, height, { w: backgroundSky.width, h: backgroundSky.height }, skyOffset + shakeX, resolution * skySpeed * playerY + shakeY);
            Render.background(ctx, backgroundHills, width, height, { w: backgroundHills.width, h: backgroundHills.height }, hillOffset + shakeX, resolution * hillSpeed * playerY + shakeY);
            Render.background(ctx, backgroundTrees, width, height, { w: backgroundTrees.width, h: backgroundTrees.height }, treeOffset + shakeX, resolution * treeSpeed * playerY + shakeY);

            // Render all paths
            renderPath(0, x, dx, playerY, maxy); // Main path
            renderPath(1, x, dx, playerY, maxy); // Left path
            renderPath(2, x, dx, playerY, maxy); // Right path

            // Render rain
            renderRain();
        }

        function renderPath(path, x, dx, playerY, maxy) {
            for (var n = 0; n < drawDistance; n++) {
                var segment = segments[(findSegment(position).index + n) % segments.length];
                if (segment.path !== path) continue;

                segment.fog = Util.exponentialFog(n / drawDistance, fogDensity);
                segment.clip = maxy;

                Util.project(segment.p1, (playerX * roadWidth) - x, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
                Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

                x += dx;
                dx += segment.curve;

                if ((segment.p1.camera.z <= cameraDepth) || (segment.p2.screen.y >= segment.p1.screen.y) || (segment.p2.screen.y >= maxy))
                    continue;

                Render.segment(ctx, width, lanes, segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.w, segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.w, segment.fog, segment.color);

                maxy = segment.p1.screen.y;
            }
        }

        function findSegment(z) {
            return segments[Math.floor(z / segmentLength) % segments.length];
        }

        function lastY(path) {
            return (segments.length == 0 || path && segments[segments.length - 1].path !== path) ? 0 : segments[segments.length - 1].p2.world.y;
        }

        function addSegment(curve, y, path) {
            var n = segments.length;
            segments.push({
                index: n,
                path: path || 0, // 0 = main path, 1 = left split, 2 = right split
                p1: { world: { y: lastY(path), z: n * segmentLength }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (n + 1) * segmentLength }, camera: {}, screen: {} },
                curve: curve,
                sprites: [],
                cars: [],
                color: Math.floor(n / rumbleLength) % 2 ? COLORS.DARK : COLORS.LIGHT
            });
        }

        function addSprite(n, sprite, offset) {
            segments[n].sprites.push({ source: sprite, offset: offset });
        }

        function addRoad(enter, hold, leave, curve, y, path) {
            var startY = lastY(path);
            var endY = startY + (Util.toInt(y, 0) * segmentLength);
            var n, total = enter + hold + leave;
            for (n = 0; n < enter; n++)
                addSegment(Util.easeIn(0, curve, n / enter), Util.easeInOut(startY, endY, n / total), path);
            for (n = 0; n < hold; n++)
                addSegment(curve, Util.easeInOut(startY, endY, (enter + n) / total), path);
            for (n = 0; n < leave; n++)
                addSegment(Util.easeInOut(curve, 0, n / leave), Util.easeInOut(startY, endY, (enter + hold + n) / total), path);
        }

        function addSplit(enter, hold, leave, curve, y) {
            addRoad(enter, hold, leave, curve, y, 1); // Left split
            addRoad(enter, hold, leave, curve, y, 2); // Right split
        }

        var ROAD = {
            LENGTH: { NONE: 0, SHORT: 25, MEDIUM: 50, LONG: 100 },
            HILL: { NONE: 0, LOW: 20, MEDIUM: 40, HIGH: 60 },
            CURVE: { NONE: 0, EASY: 2, MEDIUM: 4, HARD: 6 }
        };

        function addStraight(num, path) {
            num = num || ROAD.LENGTH.MEDIUM;
            addRoad(num, num, num, 0, 0, path);
        }

        function addHill(num, height, path) {
            num = num || ROAD.LENGTH.MEDIUM;
            height = height || ROAD.HILL.MEDIUM;
            addRoad(num, num, num, 0, height, path);
        }

        function addCurve(num, curve, height, path) {
            num = num || ROAD.LENGTH.MEDIUM;
            curve = curve || ROAD.CURVE.MEDIUM;
            height = height || ROAD.HILL.NONE;
            addRoad(num, num, num, curve, height, path);
        }

        function addLowRollingHills(num, height, path) {
            num = num || ROAD.LENGTH.SHORT;
            height = height || ROAD.HILL.LOW;
            addRoad(num, num, num, 0, height / 2, path);
            addRoad(num, num, num, 0, -height, path);
            addRoad(num, num, num, ROAD.CURVE.EASY, height, path);
            addRoad(num, num, num, 0, 0, path);
            addRoad(num, num, num, -ROAD.CURVE.EASY, height / 2, path);
            addRoad(num, num, num, 0, 0, path);
        }

        function addSCurves(path) {
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.NONE, path);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM, path);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.EASY, -ROAD.HILL.LOW, path);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.MEDIUM, path);
            addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM, path);
        }

        function addBumps(path) {
            addRoad(10, 10, 10, 0, 5, path);
            addRoad(10, 10, 10, 0, -2, path);
            addRoad(10, 10, 10, 0, -5, path);
            addRoad(10, 10, 10, 0, 8, path);
            addRoad(10, 10, 10, 0, 5, path);
            addRoad(10, 10, 10, 0, -7, path);
            addRoad(10, 10, 10, 0, 5, path);
            addRoad(10, 10, 10, 0, -2, path);
        }

        function addDownhillToEnd(num, path) {
            num = num || 200;
            addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY(path) / segmentLength, path);
        }

        function resetRoad() {
            segments = [];

            addStraight(ROAD.LENGTH.SHORT);
            addLowRollingHills();
            addSCurves();
            addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
            addBumps();
            addLowRollingHills();
            addSplit(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addCurve(ROAD.LENGTH.LONG * 2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
            addStraight();
            addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
            addSCurves();
            addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);
            addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);
            addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
            addBumps();
            addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);
            addStraight();
            addSCurves();
            addDownhillToEnd();

            resetSprites();
            resetCars();
            resetCoinSequence();

            var startLineSegment1 = segments[findSegment(playerZ).index + 1];
            var startLineSegment2 = segments[findSegment(playerZ).index + 1];

            startLineSegment1.color = { road: 'white', grass: startLineSegment1.color.grass, rumble: startLineSegment1.color.rumble };
            startLineSegment2.color = { road: 'white', grass: startLineSegment2.color.grass, rumble: startLineSegment2.color.rumble };

            for (var n = 0; n < rumbleLength; n++) {
                segments[segments.length - 1 - n].color = COLORS.FINISH;
            }

            trackLength = segments.length * segmentLength;
        }

function resetSprites() {
    addSprite(20, billboard01Sprite, -1);
    addSprite(40, billboard02Sprite, -1);
    addSprite(60, billboard03Sprite, -1);
    addSprite(80, billboard04Sprite, -1);
    addSprite(100, billboard05Sprite, -1);
    addSprite(120, billboard06Sprite, -1);
    addSprite(140, billboard07Sprite, -1);
    addSprite(160, billboard08Sprite, -1);
    addSprite(180, billboard09Sprite, -1);

    addSprite(240, billboard01Sprite, -1.2);
    addSprite(240, billboard02Sprite, 1.2);
    addSprite(segments.length - 25, billboard03Sprite, -1.2);
    addSprite(segments.length - 25, billboard04Sprite, 1.2);

    for (var n = 10; n < 200; n += 4 + Math.floor(n / 100)) {
        addSprite(n, palmTreeSprite, 1 + Math.random() * 0.5); // Right side of the road
        addSprite(n, palmTreeSprite, -1 - Math.random() * 0.5); // Left side of the road
    }

    for (var n = 250; n < 1000; n += 5) {
        addSprite(n, columnSprite, 1.1);
        addSprite(n + Util.randomInt(0, 5), tree1Sprite, -1 - (Math.random() * 2));
        addSprite(n + Util.randomInt(0, 5), tree1Sprite, -1 - (Math.random() * 2));
    }

    for (var n = 200; n < segments.length; n += 3) {
        addSprite(n, Util.randomChoice(spritesPlants), Util.randomChoice([1, -1]) * (2 + Math.random() * 5));
    }

    for (var n = 1000; n < (segments.length - 50); n += 100) {
        var side = Util.randomChoice([1, -1]);
        addSprite(n + Util.randomInt(0, 50), Util.randomChoice(spritesBillboards), -side);
        for (var i = 0; i < 20; i++) {
            var sprite = Util.randomChoice(spritesPlants);
            var offset = side * (1.5 + Math.random());
            addSprite(n + Util.randomInt(0, 50), sprite, offset);
        }
    }
}


        function resetCars() {
            cars = [];
            for (var n = 0; n < totalCars; n++) {
                var offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
                var z = Math.floor(Math.random() * segments.length) * segmentLength;
                var sprite = Util.randomChoice(spritesCars);
                var speed = maxSpeed / 4 + Math.random() * maxSpeed / (sprite === semiSprite ? 4 : 2);
                var car = { offset: offset, z: z, sprite: sprite, speed: speed };
                var segment = findSegment(car.z);
                segment.cars.push(car);
                cars.push(car);
            }
        }

        function resetCoinSequence() {
            coins = [];
            dropCoins();
        }

function dropCoins() {
    var zStart = position + playerZ + 8000; // starting z position
    var zSpacing = 2000; // spacing between coins
    // Randomly choose the number of coins to drop: either 3, 4, or 6
    var numberOfCoins = [3, 4, 6][Math.floor(Math.random() * 3)]; 
    var minSpacing = 300; // Minimum random spacing between coins
    var maxSpacing = 600; // Maximum random spacing between coins

    for (var i = 0; i < numberOfCoins; i++) {
        var offset = 0; // All coins drop in the middle lane
        var zPosition = zStart + i * zSpacing + Util.randomInt(minSpacing, maxSpacing);

        coins.push({ id: i + coins.length, offset: offset, z: zPosition, collected: false });
    }
}



        Game.run({
            canvas: canvas,
            render: render,
            update: update,
            step: step,
            images: [
                "background",
                "sprites",
                "sprites/player_straight",
                "sprites/player_uphill_straight",
                "sprites/player_uphill_left",
                "sprites/player_uphill_right",
                "sprites/player_right",
                "sprites/player_left",
                "sprites/billboard01",
                "sprites/billboard02",
                "sprites/billboard03",
                "sprites/billboard04",
                "sprites/billboard05",
                "sprites/billboard06",
                "sprites/billboard07",
                "sprites/billboard08",
                "sprites/billboard09",
                "sprites/tree1",
                "sprites/tree2",
                "sprites/dead_tree1",
                "sprites/dead_tree2",
                "sprites/palm_tree",
                "sprites/column",
                "sprites/boulder1",
                "sprites/boulder2",
                "sprites/boulder3",
                "sprites/bush1",
                "sprites/bush2",
                "sprites/cactus",
                "sprites/stump",
                "sprites/semi",
                "sprites/truck",
                "sprites/car01",
                "sprites/car02",
                "sprites/car03",
                "sprites/car04",
                "background/sky",
                "background/hills1",
                "background/trees2",
                "sprites/truck6",
                "sprites/truck8",
                "sprites/truck22",
                "sprites/truck23",
                "sprites/coin"
            ],

            keys: [
                { keys: [KEY.LEFT, KEY.A], mode: 'down', action: function () { keyLeft = true; } },
                { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function () { keyRight = true; } },
                { keys: [KEY.UP, KEY.W], mode: 'down', action: function () { keyFaster = true; } },
                { keys: [KEY.DOWN, KEY.S], mode: 'down', action: function () { keySlower = true; } },
                { keys: [KEY.LEFT, KEY.A], mode: 'up', action: function () { keyLeft = false; } },
                { keys: [KEY.RIGHT, KEY.D], mode: 'up', action: function () { keyRight = false; } },
                { keys: [KEY.UP, KEY.W], mode: 'up', action: function () { keyFaster = false; } },
                { keys: [KEY.DOWN, KEY.S], mode: 'up', action: function () { keySlower = false; } }
            ],
            ready: function (images) {
                background = images[0];
                sprites = images[1];
                playerStraightSprite = images[2];
                playerUphillStraightSprite = images[3];
                playerUphillLeftSprite = images[4];
                playerUphillRightSprite = images[5];
                playerRightSprite = images[6];
                playerLeftSprite = images[7];
                billboard01Sprite = images[8];
                billboard02Sprite = images[9];
                billboard03Sprite = images[10];
                billboard04Sprite = images[11];
                billboard05Sprite = images[12];
                billboard06Sprite = images[13];
                billboard07Sprite = images[14];
                billboard08Sprite = images[15];
                billboard09Sprite = images[16];
                tree1Sprite = images[17];
                tree2Sprite = images[18];
                deadTree1Sprite = images[19];
                deadTree2Sprite = images[20];
                palmTreeSprite = images[21];
                columnSprite = images[22];
                boulder1Sprite = images[23];
                boulder2Sprite = images[24];
                boulder3Sprite = images[25];
                bush1Sprite = images[26];
                bush2Sprite = images[27];
                cactusSprite = images[28];
                stumpSprite = images[29];
                semiSprite = images[30];
                truckSprite = images[31];
                car01Sprite = images[32];
                car02Sprite = images[33];
                car03Sprite = images[34];
                car04Sprite = images[35];
                backgroundSky = images[36];
                backgroundHills = images[37];
                backgroundTrees = images[38];
                truck1Sprite = images[39];
                truck2Sprite = images[40];
                truck3Sprite = images[41];
                truck4Sprite = images[42];
                coinSprite = images[43];

                spritesBillboards = [billboard01Sprite, billboard02Sprite, billboard03Sprite, billboard04Sprite, billboard05Sprite, billboard06Sprite, billboard07Sprite, billboard08Sprite, billboard09Sprite];
                spritesPlants = [tree1Sprite, tree2Sprite, deadTree1Sprite, deadTree2Sprite, palmTreeSprite, boulder1Sprite, boulder2Sprite, boulder3Sprite, bush1Sprite, bush2Sprite, cactusSprite, stumpSprite];
                spritesCars = [semiSprite, truckSprite, car01Sprite, car02Sprite, car03Sprite, car04Sprite, truck1Sprite, truck2Sprite, truck3Sprite, truck4Sprite];

                reset();
                localStorage.fast_lap_time = localStorage.fast_lap_time || 180;
                updateHud('fast_lap_time', formatTime(Util.toFloat(localStorage.fast_lap_time)));
            }
        });

        function reset(options) {
            options = options || {};
            canvas.width = width = window.innerWidth;
            canvas.height = height = window.innerHeight;
            lanes = 3;
            roadWidth = 2000;
            cameraHeight = 1000;
            drawDistance = 300;
            fogDensity = 5;
            fieldOfView = 100;
            segmentLength = 200;
            rumbleLength = 3;
            cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);
            playerZ = (cameraHeight * cameraDepth);
            resolution = height / 480;

            if ((segments.length == 0) || (options.segmentLength) || (options.rumbleLength))
                resetRoad();
        }

    </script>

</body>

</html>
